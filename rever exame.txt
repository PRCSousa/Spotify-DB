CREATE TABLE FUNCIONARIO 
(
FuncId INT,
Nome VARCHAR(32) NOT NULL,
DepId INT NOT NULL,
Supervisor INT,
PRIMARY KEY(FuncId),
FOREIGN KEY(DeptId) REFERENCES DEPARTAMENTO(DeptId),
FOREGIN KEY(Supervisor) REFERENCES FUNCIONARIO(FuncId)
)

2.




GRUPO D

1.

Ao executar T1 T2 e T3, a execução sequencial será equivalente
a <T1 T2 T3> ou <T2 T1 T3> (pois T1 e T2 acontecem em simultâneo)
logo os resultados possiveis podem ser:

<T1 T2 T3>

t1
c1= 100 - 100 = 0
c2 = 200 + 100 = 300

t2
c2 = 300 - 300 = 0
c3 = 300 + 300 = 600

t3
c3 = 600 - 500 = 100
c4 = 400 + 500 = 900

<T2 T1 T3>

t2
c2 = 200 - 300 | aborta

t1
c1= 100 - 100 = 0
c2 = 200 + 100 = 300

t3
c3 = 300 - 500 | aborta





2.


T1                        |   T2
wlock(CONTA[1])           |
______________________________________________________
                          |wlock(CONTA[2]) 
______________________________________________________
X1 = read(CONTA[1])       |X1 = read(CONTA[2])
X1.Saldo = X1.Saldo - 100 |X1.Saldo = X1.Saldo - 300
write(CONTA[1], X1)       |write(CONTA[2], X1)
commit()                  |commit()
                          |
_______________________________________________________
wlock(CONTA[2])           |wlock(CONTA[3])
_______________________________________________________
                          |X1 = read(CONTA[3])
       bloqueado          |X1.Saldo = X1.Saldo + 300
                          |write(CONTA[3], X1)
                          |commit()
___                   _________________________________
                          |unlock(CONTA[2])
_______________________________________________________
X1 = read(CONTA[2])       |unlock(CONTA[3])
_______________________________________________________
X1.Saldo = X1.Saldo + 100 |
write(CONTA[2], X1)       |
commit()                  |
_______________________________________________________
unlock(CONTA[1])          |
unlock(CONTA[2])          |

Neste escalonamento, foi usada uma estratégia de 2pl 
(todos os locks acontecem no início, e só no fim são são dados unlocks),
o que faz com que pelo menos uma das transações fique temporáriamente
bloqueada (neste caso a T1 ao tentar dar lock à conta 2 aberta à priori por T2).




funcionario 
 ->  Funcid
|    nome
|    depid    -->       
|-   supervisor

Select DepId, COUNT(FuncID) as N
from funcionario
where supervisor = NULL
group by DepId
Order by N, DepId
having N >= 5


R0 <- DeptId F N = COUNT(FuncId)(F)
R1 <- σ Supervisor = Null (R0)
R2 <- P DeptId, N(R1)
R3 <- σ N >= 5(R2)






GRUPO B

1.
ou a T1 executam ou a T2 executa

se a t1 executar
1 - 0
2 - 300
3 - 300
4 - 400

e t3 executa, t4 não

1 - 0
2 - 100
3 - 300
4 - 600

se t2 executar, t1 nao executa
1 - 0
2 - 200
3 - 400
4 - 400

t3 executa

1 - 0
2 - 0
3 - 400
4 - 600x

e t4

t4 executa

1 - 0
2 - 0
3 - 0
4 - 1000



N = 16_000
R = 400
B = 4096
B' = 4088
bfr = 4088 / 400 = 10 e sobra 88
n = 16_000 / 10 = 1600

tempo de procura = log(1600)

cada linha ocupa 8 bytes por referência, 24 bytes por bloco = 32 bytes por linha


bfr1 = 4088 / 32 = 127 referências por bloco.

n1 = 16_000 / 127 = 125 blocos para guardar as 16k entradas.



